generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserMode {
  LANDLORD
  TENANT
}

enum LeaseType {
  LONG_TERM
  SHORT_TERM
  STUDENT
  COLOCATION
}

enum GuarantorType {
  FAMILY
  THIRD_PARTY
  VISALE
  LEGAL_ENTITY
  CAUTIONNER
  GARANTME
}

enum GuarantorStatus {
  CDI
  CDD
  RETIRED
  STUDENT
  UNEMPLOYED
  OTHER
}

enum IncomeType {
  RENTAL
  ALIMONY
  SCHOLARSHIP
  SOCIAL_AID
  OTHER
}

enum Plan {
  FREE
  PLUS
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  GIFTED
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id             String    @id @default(uuid())
  name           String?
  email          String?   @unique
  emailVerified  DateTime?
  image          String?
  hashedPassword String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  favoriteIds    String[]
  
  // Explicit Identity
  firstName      String?
  lastName       String?

  // Coridor Fields
  role              UserRole  @default(USER)
  isBanned          Boolean   @default(false)
  userMode          UserMode  @default(TENANT)
  plan              Plan      @default(FREE)
  phoneNumber       String?
  birthDate         DateTime?
  birthPlace        String?
  address           String?
  addressLine1      String?
  building          String?
  apartment         String?
  city              String?
  zipCode           String?
  country           String?
  measurementSystem String?   @default("metric") // "metric" or "imperial"
  nationality   String?
  stripeCustomerId String?

  accounts     Account[]
  // listings     Listing[] // REMOVED in 3-Tier Refactor
  properties   Property[]

  wishlists    Wishlist[]

  tenantProfile TenantProfile?

  conversations Conversation[]
  seenMessages  Message[]      @relation("Seen")

  messages      Message[]
  visits        Visit[] // Visits as candidate
  createdScopes TenantCandidateScope[] @relation("CreatedScope")

  // Contacts System
  uniqueCode String? @unique
  contacts   User[]  @relation("UserContacts")
  contactOf  User[]  @relation("UserContacts")
  commuteLocations CommuteLocation[] // NEW: Relation to commute locations
  likes            Like[]

  // Reporting
  reports          Report[] @relation("Reporter")
  reported         Report[] @relation("ReportedUser")
  visitSlots       VisitSlot[]   // Availability linked to User + Location
  bankConnections  BankConnection[] // NEW: Banking Connectivity
  pushSubscriptions PushSubscription[]
  sessions         Session[] // NEW for DB Auth
  notificationPreferences NotificationPreferences?
  
  // Search Alerts
  searchAlerts     SearchAlert[]

  notifications    Notification[]

  // Community Polls
  createdPolls     NeighborhoodPoll[] @relation("PollCreator")
  pollVotes        PollResponse[]     @relation("PollVotes")

  // Subscriptions
  subscriptions       Subscription[]
  giftedSubscriptions Subscription[] @relation("GiftedSubscriptions")
  invoices            Invoice[]
  userSubscription    UserSubscription?

  legalReminders      LegalReminder[]

  // --- Passeport Locatif ---
  landlordReviews   LandlordReview[] @relation("LandlordReviews")

  // --- État des Lieux ---
  inspectionsAsLandlord Inspection[] @relation("InspectionLandlord")
  inspectionsAsTenant   Inspection[] @relation("InspectionTenant")
}

model TenantProfile {
  id        String  @id @default(uuid())
  userId    String  @unique
  jobType   String?
  jobTitle  String?
  netSalary Int?

  // Partner Info
  partnerJobType   String?
  partnerJobTitle  String?
  partnerNetSalary Int?

  // Banking Analysis Helper (Privacy)
  landlordName     String? // To filter transactions strictly

  // APL Info
  aplAmount        Int?
  aplDirectPayment Boolean @default(false)

  // Rent Verification (GoCardless)
  rentVerified       Boolean @default(false)
  detectedRentAmount Int?
  rentPaymentDate    Int? // Day of the month (1-31)

  // Badge Payeur Exemplaire
  badgeLevel         String?   // "BRONZE", "SILVER", "GOLD" or null
  verifiedMonths     Int       @default(0)
  punctualityRate    Float?    // 0-100
  lastVerifiedAt     DateTime?
  verificationStatus String?   // "PENDING", "VERIFIED", "FAILED", "EXPIRED"

  // Bio
  bio               String?

  user              User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  guarantors        Guarantor[]
  additionalIncomes Income[]

  // --- Passeport Locatif ---
  rentalHistory     RentalHistory[]
  passportSettings  PassportSettings?
}

model Guarantor {
  id              String          @id @default(uuid())
  tenantProfileId String
  type            GuarantorType
  status          GuarantorStatus
  netIncome       Int

  tenantProfile     TenantProfile @relation(fields: [tenantProfileId], references: [id], onDelete: Cascade)
  additionalIncomes Income[]
}

model Income {
  id     String     @id @default(uuid())
  type   IncomeType
  amount Int

  tenantProfileId String?
  tenantProfile   TenantProfile? @relation(fields: [tenantProfileId], references: [id], onDelete: Cascade)

  guarantorId String?
  guarantor   Guarantor? @relation(fields: [guarantorId], references: [id], onDelete: Cascade)
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}



model Property {
  id              String   @id @default(uuid())
  ownerId         String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Physical Characteristics
  category        String   // Apartment, House, etc.
  constructionYear Int?
  constructionPeriod String? // e.g. "Avant 1948", "1949 - 1974"
  totalSurface    Float?   // Surface totale du bien
  purchasePrice   Int?     // Prix d'achat (Euros)
  
  // Location
  address         String?  // Full address string
  addressLine1    String?
  building        String?
  apartment       String? // Complement d'adresse
  city            String?
  zipCode         String?
  country         String?
  latitude        Float?
  longitude       Float?
  district        String?
  neighborhood    String?
  
  // Global Amenities (Building/Property context)
  isNearTransport   Boolean @default(false)
  isNearShops       Boolean @default(false)
  isNearSchools     Boolean @default(false)
  isNearGreenSpace  Boolean @default(false)
  isNearHospital    Boolean @default(false)
  isQuietArea       Boolean @default(false)
  
  hasSeparateKitchen Boolean @default(false) // NEW field
  hasSofteners      Boolean @default(false) // Adoucisseur
  hasFiber          Boolean @default(false)
  hasBikeRoom       Boolean @default(false)
  hasElevator       Boolean @default(false)
  isAccessible      Boolean @default(false) // PMR
  hasDigicode       Boolean @default(false)
  digicodeValue     String?
  hasIntercom       Boolean @default(false)
  hasCaretaker      Boolean @default(false)
  hasPool           Boolean @default(false)

  // Meters & Utilities
  electricMeterPDL  String?  // Point de Livraison (PDL) compteur électrique

  // Energy Performance
  dpe             String?
  ges             String?
  dpe_year        Int?
  energy_cost_min Int?
  energy_cost_max Int?
  heatingSystem   String?
  glazingType     String?

  // ---- DIAGNOSTICS IMMOBILIERS ----
  dpeDate                   DateTime? @db.Date
  dpeExpiryDate             DateTime? @db.Date
  electricalDiagnosticDate  DateTime? @db.Date
  electricalInstallYear     Int?
  gasDiagnosticDate         DateTime? @db.Date
  gasInstallYear            Int?
  hasGasInstallation        Boolean   @default(false)
  erpDate                   DateTime? @db.Date

  // Physical Characteristics (Moved from RentalUnit)
  totalFloors     Int?
  floor           Int? // Floor of the property
  
  isTraversant      Boolean @default(false)
  isSouthFacing     Boolean @default(false)
  isBright          Boolean @default(false)
  hasGarden         Boolean @default(false)
  hasBalcony        Boolean @default(false)
  hasView           Boolean @default(false)
  hasAirConditioning Boolean @default(false)
  hasBathtub        Boolean @default(false)
  isRefurbished     Boolean @default(false)
  isQuiet           Boolean @default(false)
  hasNoOpposite     Boolean @default(false)

  // ---- ZONE TENDUE / ENCADREMENT DES LOYERS ----
  isZoneTendue              Boolean   @default(false)
  referenceRent             Float?    // Loyer de référence EUR/m²/mois
  referenceRentIncreased    Float?    // Loyer de référence majoré EUR/m²/mois
  rentSupplement            Float?    // Complément de loyer EUR
  rentSupplementJustification String?
  previousRent              Float?    // Dernier loyer appliqué (EUR)
  previousRentDate          DateTime? @db.Date

  // ---- ANNEXES / LOCAUX ACCESSOIRES ----
  hasCave           Boolean   @default(false)
  caveReference     String?
  hasParking        Boolean   @default(false)
  parkingReference  String?
  hasGarage         Boolean   @default(false)
  garageReference   String?

  // ---- ÉQUIPEMENTS COMPLÉMENTAIRES ----
  waterHeatingSystem  String?   // IND_ELEC, COL_GAZ, etc.

  // ---- REGIME JURIDIQUE ----
  legalRegime         String?   // "COPROPRIETE" or "MONOPROPRIETE"

  // ---- QUALITE DU BAILLEUR ----
  ownerLegalStatus    String?   // "PERSONNE_PHYSIQUE", "SCI", "PERSONNE_MORALE"
  ownerSiren          String?   // Numéro SIREN si personne morale
  ownerSiege          String?   // Siège social si personne morale

  // ---- DIAGNOSTICS COMPLÉMENTAIRES ----
  leadDiagnosticDate        DateTime? @db.Date   // CREP (plomb)
  leadDiagnosticResult      String?              // POSITIF, NEGATIF, NON_APPLICABLE
  asbestosDiagnosticDate    DateTime? @db.Date   // Amiante
  asbestosDiagnosticResult  String?

  // Diagnostic Bruit
  noiseDiagnosticDate     DateTime? @db.Date
  noiseDiagnosticResult   String?

  // Relations
  owner           User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  rentalUnits     RentalUnit[]
  rooms           Room[]        // Physical rooms (Salon, Cuisine, etc.)
  images          PropertyImage[] // Common Area images

  
  // Caching/Transit
  transitData     Json?

  expenses              Expense[]
  reconciliationHistory ReconciliationHistory[]

  legalReminders      LegalReminder[]

  // --- État des Lieux ---
  inspections         Inspection[]

  @@index([ownerId])
}

enum RentalUnitType {
  ENTIRE_PLACE
  PRIVATE_ROOM
  SHARED_ROOM
}

model RentalUnit {
  id          String         @id @default(uuid())
  propertyId  String
  name        String         // "Appartement Entier" or "Chambre 1"
  type        RentalUnitType
  isActive    Boolean        @default(true)
  
  // Specific Characteristics
  surface     Float?
  bedType     String? // "SINGLE", "DOUBLE", "NONE"
  roomCount   Int?    // Nombre de pièces principales
  
  // Amenities specific to this unit
  isFurnished       Boolean @default(false)
  hasPrivateBathroom Boolean @default(false)
  
  // Room Link (for Colocation/Private Room)
  targetRoomId      String?  // If this unit corresponds to a specific physical room
  targetRoom        Room?    @relation(fields: [targetRoomId], references: [id])
  
  property    Property       @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  listings    Listing[]
  images      PropertyImage[] // Unit specific images
  expenses    Expense[]
}

model Listing {
  id            String   @id @default(uuid())
  rentalUnitId  String
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  statusUpdatedAt DateTime @default(now())
  
  // Commercial Offer
  price         Int      // Loyer hors charges
  charges       Json?    // { amount: 100, included: true/false }
  securityDeposit Int?
  
  isPublished   Boolean  @default(false)
  status        String   @default("DRAFT") // DRAFT, PENDING_REVIEW, PUBLISHED, REJECTED, ARCHIVED
  
  // Moderation
  rejectionReason String?
  reviewedAt      DateTime?
  reviewedBy      String?
  reports         Report[]
  
  availableFrom DateTime?
  
  // Marketing
  title         String
  description   String
  propertyAdjective String? // "Lumineux", "Spacieux"
  
  // Target Constraints
  roomCount     Int?     // Overrides unit room count if necessary
  bathroomCount Int?
  guestCount    Int?
  
  isStudentFriendly Boolean @default(false)
  petsAllowed       Boolean @default(false)
  
  leaseType     LeaseType?

  // ---- CONDITIONS DU BAIL ----
  chargesAmount             Int?        // Montant charges en euros (typed alternative to Json charges)
  chargesIncluded           Boolean     @default(false)
  chargesType               String?     // "PROVISION" | "FORFAIT"
  paymentDay                Int         @default(1)      // Jour du mois (1-28)
  paymentMethod             String      @default("VIREMENT")  // VIREMENT, CHEQUE, PRELEVEMENT, ESPECES
  recentWorksAmountCents    Int         @default(0)
  recentWorksDescription    String      @default("Néant")
  agencyFeesAmount   Int?   // Honoraires agence (si applicable)

  // Relations
  rentalUnit    RentalUnit @relation(fields: [rentalUnitId], references: [id], onDelete: Cascade)
  
  // User Interactions (Commercial Links)

  wishlists     Wishlist[]
  conversations Conversation[]
  visits        Visit[]
  applications  RentalApplication[]
  messages      Message[]
  likes         Like[]
  
  // Furniture Inventory (Commercial/Legal)
  furniture     Furniture?
  
  // Legacy User Link (Can be inferred via Property, but useful for fast access/queries)
  // userId        String
  // user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([rentalUnitId])
  
  // Search optimization
  @@index([description])
  @@index([title])
  @@index([price])
  @@index([roomCount])
  @@index([createdAt])
  @@index([status])
}

model Furniture {
  id        String  @id @default(uuid())
  listingId String  @unique
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Mandatory (Meublé)
  bedding  Boolean @default(false)
  curtains Boolean @default(false)
  hob      Boolean @default(false)
  oven     Boolean @default(false)
  fridge   Boolean @default(false)
  freezer  Boolean @default(false)
  dishes   Boolean @default(false)
  utensils Boolean @default(false)
  table    Boolean @default(false)
  seats    Boolean @default(false)
  shelves  Boolean @default(false)
  lights   Boolean @default(false)
  vacuum   Boolean @default(false)

  // Optional
  washingMachine Boolean @default(false)
  coffeeMaker    Boolean @default(false)
  toaster        Boolean @default(false)
  dishwasher     Boolean @default(false)
  hairDryer      Boolean @default(false)
  mirror         Boolean @default(false)
  sheets         Boolean @default(false)
  towels         Boolean @default(false)
  cloths         Boolean @default(false)
}

model VisitSlot {
  id          String   @id @default(uuid())
  userId      String   // Availability is linked to User
  
  date        DateTime
  startTime   String
  endTime     String
  
  // Location of the Landlord's presence
  latitude    Float
  longitude   Float
  address     String?
  radius      Int      @default(200) // Match radius in meters

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([date])
}

enum VisitStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

model Visit {
  id              String      @id @default(uuid())
  listingId       String
  candidateId     String
  date            DateTime
  startTime       String
  endTime         String
  status          VisitStatus @default(PENDING)
  confirmedAt     DateTime?
  reminderSentAt  DateTime?
  createdAt       DateTime    @default(now())

  applicationId   String?
  application     RentalApplication? @relation(fields: [applicationId], references: [id], onDelete: SetNull)

  listing     Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  candidate   User    @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  evaluation  CandidateEvaluation?

  @@index([listingId])
  @@index([candidateId])
  @@index([date])
  @@index([status])
  @@index([applicationId])
}

model Room {
  id          String   @id @default(uuid())
  name        String
  propertyId  String   // CHANGED: Room belongs to Property
  
  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  images      PropertyImage[]
  
  // Reverse relation for RentalUnit logic targeting a specific room
  rentalUnits RentalUnit[]

  // --- État des Lieux ---
  inspectionRooms InspectionRoom[]

  @@index([propertyId])
}

model PropertyImage {
  id           String  @id @default(uuid())
  url          String
  order        Int     @default(0)
  
  // Can belong to Property (Common areas) OR RentalUnit (Private areas)
  propertyId   String?
  rentalUnitId String?
  roomId       String?
  
  property     Property?   @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  rentalUnit   RentalUnit? @relation(fields: [rentalUnitId], references: [id], onDelete: Cascade)
  room         Room?       @relation(fields: [roomId], references: [id])

  @@index([propertyId])
  @@index([rentalUnitId])
}



model Wishlist {
  id        String   @id @default(uuid())
  userId    String
  name      String
  createdAt DateTime @default(now())

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  listings Listing[]

  @@index([userId])
}

model Conversation {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now())
  lastMessageAt DateTime @default(now())
  name          String?
  isGroup       Boolean?

  messagesIds String[]
  messages    Message[]

  users User[]

  listingId String?
  listing   Listing? @relation(fields: [listingId], references: [id])
  
  @@index([listingId])
  @@index([lastMessageAt])
}

model Message {
  id        String   @id @default(uuid())
  body      String?
  image     String?
  createdAt DateTime @default(now())

  seenIds String[]
  seen    User[]   @relation("Seen")

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  listingId String?
  listing   Listing? @relation(fields: [listingId], references: [id])

  // Attachments
  fileUrl   String?
  fileName  String?
  fileType  String? // image/png, application/pdf, etc.
  
  @@index([conversationId])
  @@index([senderId])
}

// model Amenity {
//   id        String                                @id @default(uuid())
//   type      String
//   latitude  Float
//   longitude Float
//   name      String?
//   city      String?
//   zipCode   String?
//   sourceId  String?                               @unique
//   geom      Unsupported("geometry(Point, 4326)")?
//   createdAt DateTime                              @default(now())
//   updatedAt DateTime                              @updatedAt
//
//   @@index([geom], name: "amenity_geom_idx", type: Gist)
// }

enum CompositionType {
  SOLO
  COUPLE
  GROUP
}

enum CoupleLegalStatus {
  NONE
  MARRIED
  PACS
  CONCUBINAGE
}

enum TargetLeaseType {
  ANY
  FURNISHED
  EMPTY
  MOBILITY
}

model TenantCandidateScope {
  id                String             @id @default(uuid())
  creatorUserId     String
  compositionType   CompositionType
  membersIds        String[]
  coupleLegalStatus CoupleLegalStatus?
  targetLeaseType   TargetLeaseType
  childCount        Int                @default(0)
  targetMoveInDate  DateTime?
  createdAt         DateTime           @default(now())

  creatorUser  User                @relation("CreatedScope", fields: [creatorUserId], references: [id], onDelete: Cascade)
  applications RentalApplication[]

  @@index([creatorUserId])
}

enum ApplicationStatus {
  PENDING
  SENT
  REJECTED
  VISIT_PROPOSED
  VISIT_CONFIRMED
  SHORTLISTED
  FINALIST
  SELECTED
  ACCEPTED
}

enum EvaluationCriterion {
  PUNCTUALITY
  FILE_COMPLETENESS
  INCOME_ADEQUACY
  GUARANTOR_QUALITY
  LEASE_COMPATIBILITY
  MOVE_IN_FLEXIBILITY
  INTEREST_LEVEL
  QUESTIONS_ASKED
  CONDITIONS_GRASPED
  RENTAL_PROJECT
  COUP_DE_COEUR
}

enum EvaluationDecision {
  SHORTLISTED
  UNDECIDED
  ELIMINATED
}

enum LeaseStatus {
  DRAFT
  PENDING_SIGNATURE
  SIGNED
}

enum SpecificLeaseRequest {
  DEFAULT
  STUDENT
  MOBILITY
}

model RentalApplication {
  id                   String               @id @default(uuid())
  listingId            String
  candidateScopeId     String
  status               ApplicationStatus    @default(SENT)
  specificLeaseRequest SpecificLeaseRequest @default(DEFAULT)
  appliedAt            DateTime             @default(now())
  rejectionReason      String?
  rejectedAt           DateTime?

  // Lease & Signature
  leaseStatus        LeaseStatus @default(DRAFT)
  yousignSignatureId String? // Signature Request ID
  signedLeaseUrl     String? // URL of final signed PDF

  // Lease Indexation
  indexationQuarter  Int?    // 1, 2, 3, or 4
  baseIndexValue     Float?  // Index value at lease signature

  // ---- DATES ET DURÉE DU BAIL ----
  leaseStartDate       DateTime? @db.Date   // Date d'effet du bail
  moveInDate           DateTime? @db.Date   // Date d'entrée dans les lieux
  leaseDurationMonths  Int?                 // Durée personnalisable
  mobilityReason       String?              // Motif bail mobilité (obligatoire si BAIL_MOBILITE)

  // ---- RAPPELS LEGAUX ----
  leaseEndDate              DateTime? @db.Date
  keysReturnDate            DateTime?
  tenantInsuranceLastDate   DateTime?
  tenantInsuranceDocUrl     String?

  listing        Listing              @relation(fields: [listingId], references: [id], onDelete: Cascade)
  candidateScope TenantCandidateScope @relation(fields: [candidateScopeId], references: [id], onDelete: Cascade)

  reconciliationHistory ReconciliationHistory[]

  // Financial History
  financials         LeaseFinancials[]
  matchedTransactions BankTransaction[]
  rentReceipts       RentReceipt[]

  legalReminders      LegalReminder[]
  rentPaymentTrackings RentPaymentTracking[]

  // Selection
  visits             Visit[]
  evaluation         CandidateEvaluation?

  // --- Passeport Locatif ---
  rentalHistory      RentalHistory?

  // --- Guide d'emménagement ---
  moveInGuide        MoveInGuide?

  // --- État des Lieux ---
  inspections        Inspection[]

  @@index([listingId])
  @@index([candidateScopeId])
  @@index([status])
}

model LeaseFinancials {
  id                   String   @id @default(uuid())
  rentalApplicationId  String
  
  baseRentCents        Int      // Loyer hors charges
  serviceChargesCents  Int      // Provision sur charges
  
  startDate            DateTime @db.Date // Date d'entrée en vigueur
  endDate              DateTime? @db.Date // Date de fin (null = actif)

  createdAt            DateTime @default(now())

  rentalApplication    RentalApplication @relation(fields: [rentalApplicationId], references: [id], onDelete: Cascade)

  @@index([rentalApplicationId])
}

model RentReceipt {
  id                  String   @id @default(uuid())
  rentalApplicationId String

  periodStart         DateTime @db.Date
  periodEnd           DateTime @db.Date

  rentAmountCents     Int      // Loyer HC payé
  chargesAmountCents  Int      // Charges payées
  totalAmountCents    Int      // Total payé

  isPartialPayment    Boolean  @default(false)

  pdfUrl              String?
  sentAt              DateTime?

  createdAt           DateTime @default(now())

  rentalApplication   RentalApplication @relation(fields: [rentalApplicationId], references: [id], onDelete: Cascade)

  @@unique([rentalApplicationId, periodStart])
  @@index([rentalApplicationId])
}

// NEW: Commute Location Model
model CommuteLocation {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name          String   // e.g., "Travail", "École"
  address       String
  latitude      Float
  longitude     Float
  transportMode String   @default("TRANSIT") // TRANSIT, DRIVING, CYCLING, WALKING
  icon          String?  // NEW: Icon name (e.g., 'briefcase', 'home')
  isShowOnMap   Boolean  @default(true) // NEW: Toggle visibility on map
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

model Like {
  id        String   @id @default(uuid())
  userId    String
  listingId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
  @@index([userId])
  @@index([listingId])
}

// EXPENSES & RECONCILIATION

enum ExpenseCategory {
  COLD_WATER
  HOT_WATER
  ELECTRICITY_COMMON
  ELECTRICITY_PRIVATE
  HEATING_COLLECTIVE
  TAX_PROPERTY
  ELEVATOR
  INSURANCE
  MAINTENANCE
  CARETAKER
  OTHER
  METERS
  GENERAL_CHARGES
  BUILDING_CHARGES
  PARKING
  INSURANCE_GLI
}

enum ExpenseFrequency {
  ONCE
  MONTHLY
  QUARTERLY
  YEARLY
}

model Expense {
  id                     String           @id @default(uuid())
  propertyId             String
  rentalUnitId           String?
  category               ExpenseCategory
  label                  String
  amountTotalCents       Int
  dateOccurred           DateTime         @db.Date
  frequency              ExpenseFrequency
  isRecoverable          Boolean
  recoverableRatio       Float            @default(1.0)
  proofUrl               String?
  isFinalized            Boolean          @default(false)
  amountRecoverableCents Int?             // Computed or manually set? Image doesn't specify logic, just field.
  amountDeductibleCents  Int?             // NEW: Montant déductible des impôts

  property               Property         @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  rentalUnit             RentalUnit?      @relation(fields: [rentalUnitId], references: [id])
  
  reconciliationItems    ReconciliationItem[]

  @@index([propertyId])
  @@index([rentalUnitId])
  @@index([dateOccurred])
}

model ReconciliationHistory {
  id                    String   @id @default(uuid())
  propertyId            String
  leaseId               String   // Linked to RentalApplication (Lease)
  
  periodStart           DateTime @db.Date
  periodEnd             DateTime @db.Date
  
  totalRealChargesCents Int
  totalProvisionsCents  Int
  finalBalanceCents     Int      // Debiteur or Crediteur
  
  reportUrl             String?
  createdAt             DateTime @default(now())

  property              Property          @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  lease                 RentalApplication @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  
  items                 ReconciliationItem[]

  @@index([propertyId])
  @@index([leaseId])
}

model ReconciliationItem {
  reconciliationId String
  expenseId        String

  reconciliation   ReconciliationHistory @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)
  expense          Expense               @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  @@id([reconciliationId, expenseId])
  @@index([reconciliationId])
  @@index([expenseId])
}
model RentIndex {
  id          String   @id @default(uuid())
  quarter     Int
  year        Int
  value       Float
  publishedAt DateTime

  @@unique([year, quarter])
}
// BANKING CONNECTIVITY
model BankConnection {
  id           String   @id @default(uuid())
  userId       String
  provider     String   @default("POWENS")
  connectionId String?  // Powens External ID
  
  accessToken  String?  @db.Text
  refreshToken String?  @db.Text
  tokenExpiresAt DateTime?

  lastSyncedAt DateTime?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions BankTransaction[]
  
  @@unique([userId, connectionId]) 
  @@index([userId])
}

model BankTransaction {
  id               String   @id @default(uuid())
  bankConnectionId String
  remoteId         String   // Powens Transaction ID
  
  date             DateTime
  label            String   // Wording
  amount           Float    // Positive = Credit, Negative = Debit
  currency         String   @default("EUR")
  
  category         String?  // Powens Category
  
  isProcessed      Boolean  @default(false)
  
  // Link to Lease if we matched it (Rent Payment)
  matchedLeaseId   String?
  matchedLease     RentalApplication? @relation(fields: [matchedLeaseId], references: [id])
  
  createdAt        DateTime @default(now())

  bankConnection   BankConnection @relation(fields: [bankConnectionId], references: [id], onDelete: Cascade)
  
  @@unique([bankConnectionId, remoteId])
}

model PushSubscription {
  id        String   @id @default(uuid())
  endpoint  String
  keys      Json
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model NotificationPreferences {
  id        String  @id @default(uuid())
  userId    String  @unique
  
  // Notification toggles by type
  enableMessages      Boolean @default(true)
  enableVisits        Boolean @default(true)
  enableApplications  Boolean @default(true)
  enableLikes         Boolean @default(false) // Disabled by default to avoid spam
  
  // Do Not Disturb hours (24h format)
  dndStartHour Int? // Example: 22 = 10pm
  dndEndHour   Int? // Example: 8 = 8am

  enableLegalReminders      Boolean @default(true)
  legalReminderLeadDays     Int     @default(30)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Report {
  id             String   @id @default(uuid())
  reason         String
  details        String?
  status         String   @default("PENDING") // PENDING, RESOLVED, DISMISSED
  createdAt      DateTime @default(now())

  reporter       User     @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reporterId     String

  // Optional targets
  listing        Listing? @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId      String?

  targetUser     User?    @relation("ReportedUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  targetUserId   String?
}

model SearchAlert {
  id             String   @id @default(uuid())
  createdAt      DateTime @default(now())

  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  email          String?

  // Criteria
  locationValue  String?
  category       String?
  minPrice       Int?
  maxPrice       Int?
  roomCount      Int?

  frequency      String   @default("INSTANT") // INSTANT, DAILY, WEEKLY
  isActive       Boolean  @default(true)

  // Statistics
  lastSentAt     DateTime?
  matchCount     Int      @default(0)
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String   // SYSTEM, MESSAGE, BOOKING, LISTING_APPROVED, etc.
  title     String
  message   String
  link      String?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CandidateEvaluation {
  id              String              @id @default(uuid())
  visitId         String              @unique
  applicationId   String              @unique
  decision        EvaluationDecision
  compositeScore  Float               @default(0)
  evaluatedAt     DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  visit           Visit               @relation(fields: [visitId], references: [id], onDelete: Cascade)
  application     RentalApplication   @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  scores          EvaluationScore[]

  @@index([applicationId])
  @@index([compositeScore])
}

model EvaluationScore {
  id              String              @id @default(uuid())
  evaluationId    String
  criterion       EvaluationCriterion
  score           Int

  evaluation      CandidateEvaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  @@unique([evaluationId, criterion])
  @@index([evaluationId])
}

// ── Community Neighborhood Polls ─────────────────────────────────────────

enum PollCategory {
  NOISE_LEVEL
  SAFETY
  TRANSPORT
  SHOPPING
  SCHOOLS
  PARKING
  GREEN_SPACES
  COMMUNITY_SPIRIT
}

enum PollStatus {
  ACTIVE
  CLOSED
  ARCHIVED
}

model NeighborhoodPoll {
  id            String       @id @default(uuid())
  title         String
  description   String?
  category      PollCategory
  status        PollStatus   @default(ACTIVE)
  option1       String
  option2       String
  option3       String
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  closedAt      DateTime?

  createdById   String
  createdBy     User         @relation("PollCreator", fields: [createdById], references: [id], onDelete: Cascade)

  responses     PollResponse[]

  @@index([status])
  @@index([category])
  @@index([createdById])
}

model PollResponse {
  id             String   @id @default(uuid())
  selectedOption Int
  latitude       Float?
  longitude      Float?
  neighborhood   String?
  city           String?
  zipCode        String?
  pollId         String
  poll           NeighborhoodPoll @relation(fields: [pollId], references: [id], onDelete: Cascade)
  userId         String
  user           User     @relation("PollVotes", fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime @default(now())

  @@unique([pollId, userId])
  @@index([pollId])
  @@index([userId])
  @@index([city])
  @@index([zipCode])
}

// ── Subscription Management ─────────────────────────────────────────

model Subscription {
  id          String             @id @default(uuid())
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan        Plan
  status      SubscriptionStatus @default(ACTIVE)
  startDate   DateTime           @default(now())
  endDate     DateTime?
  isGifted    Boolean            @default(false)
  giftedById  String?
  giftedBy    User?              @relation("GiftedSubscriptions", fields: [giftedById], references: [id], onDelete: SetNull)
  giftReason  String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  invoices    Invoice[]

  @@index([userId])
  @@index([status])
  @@index([endDate])
}

model Invoice {
  id              String        @id @default(uuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionId  String?
  subscription    Subscription? @relation(fields: [subscriptionId], references: [id])
  amountCents     Int
  description     String
  status          String        @default("PAID")
  invoiceDate     DateTime      @default(now())
  pdfUrl          String?
  createdAt       DateTime      @default(now())

  @@index([userId])
  @@index([invoiceDate])
}

// ── Stripe Subscription System ──────────────────────────────

model Feature {
  id          String   @id @default(uuid())
  key         String   @unique  // e.g. "LEASE_GENERATION", "RENT_TRACKING"
  label       String             // Display name: "Génération de baux"
  description String?
  category    String   @default("GENERAL") // "LOCATION", "FINANCE", "SUPPORT", etc.
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  planFeatures PlanFeature[]
}

model SubscriptionPlan {
  id              String   @id @default(uuid())
  name            String   @unique  // "FREE", "ESSENTIAL", "PRO"
  displayName     String            // "Gratuit", "Essentiel", "Pro"
  description     String?
  monthlyPriceCents Int   @default(0)
  yearlyPriceCents  Int   @default(0)
  stripePriceIdMonthly String?
  stripePriceIdYearly  String?
  maxProperties   Int      @default(1)
  isActive        Boolean  @default(true)
  sortOrder       Int      @default(0)
  isPopular       Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  planFeatures    PlanFeature[]
  userSubscriptions UserSubscription[]
}

model PlanFeature {
  id             String           @id @default(uuid())
  planId         String
  featureId      String
  limitValue     Int?             // null = unlimited, e.g. maxProperties override

  plan           SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
  feature        Feature          @relation(fields: [featureId], references: [id], onDelete: Cascade)

  @@unique([planId, featureId])
  @@index([planId])
  @@index([featureId])
}

model UserSubscription {
  id                    String           @id @default(uuid())
  userId                String           @unique
  planId                String
  stripeCustomerId      String?
  stripeSubscriptionId  String?
  status                String           @default("ACTIVE") // ACTIVE, PAST_DUE, CANCELLED, TRIALING
  billingCycle          String           @default("MONTHLY") // MONTHLY, YEARLY
  currentPeriodStart    DateTime?
  currentPeriodEnd      DateTime?
  cancelAtPeriodEnd     Boolean          @default(false)
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt

  user                  User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan                  SubscriptionPlan @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([status])
}


// ── Legal Reminders ─────────────────────────────────────────

enum LegalReminderType {
  DPE_EXPIRY
  ELECTRICAL_DIAGNOSTIC_EXPIRY
  GAS_DIAGNOSTIC_EXPIRY
  ERP_EXPIRY
  RENT_FREEZE_DPE_FG
  LEASE_END_NOTICE_LANDLORD
  RENT_REVISION_IRL
  CHARGES_REGULARIZATION
  DEPOSIT_RETURN_DEADLINE
  TENANT_INSURANCE_CHECK
  TAX_DECLARATION_DEADLINE
  CUSTOM
}

enum LegalReminderStatus {
  PENDING
  UPCOMING
  NOTIFIED
  COMPLETED
  DISMISSED
  OVERDUE
}

enum LegalReminderPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model LegalReminder {
  id                    String                @id @default(uuid())

  userId                String
  propertyId            String?
  rentalApplicationId   String?

  type                  LegalReminderType
  priority              LegalReminderPriority @default(MEDIUM)
  title                 String
  description           String?
  legalReference        String?
  actionUrl             String?

  dueDate               DateTime
  reminderDate          DateTime
  secondReminderDate    DateTime?
  recurrenceRule        String?
  nextOccurrence        DateTime?

  status                LegalReminderStatus   @default(PENDING)
  completedAt           DateTime?
  dismissedAt           DateTime?
  dismissReason         String?

  notifiedAt            DateTime?
  secondNotifiedAt      DateTime?

  isAutoGenerated       Boolean               @default(true)
  sourceField           String?
  metadata              Json?

  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  user                  User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  property              Property?             @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  rentalApplication     RentalApplication?    @relation(fields: [rentalApplicationId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([propertyId])
  @@index([rentalApplicationId])
  @@index([dueDate])
  @@index([reminderDate])
  @@index([status])
  @@index([type])
  @@index([userId, status])
}

// ── Rent Payment Tracking ─────────────────────────────────────

enum RentPaymentStatus {
  PENDING
  PAID
  LATE
  REMINDER_SENT
  OVERDUE
  CRITICAL
  MANUALLY_CONFIRMED
  IGNORED
}

// ============================================================
// ENUMS -- Passeport Locatif
// ============================================================

/// Type de bien pour l'historique locatif.
/// Utilise pour les saisies manuelles (les baux Coridor ont deja
/// le type via Property.category).
enum RentalPropertyType {
  APARTMENT       // Appartement
  HOUSE           // Maison
  STUDIO          // Studio
  COLOCATION_ROOM // Chambre en colocation
  OTHER           // Autre
}

/// Source de l'entree dans l'historique.
/// CORIDOR = genere automatiquement depuis un bail signe.
/// MANUAL = saisi par le locataire (declaratif, non verifie).
enum RentalHistorySource {
  CORIDOR   // Bail Coridor (verifie automatiquement)
  MANUAL    // Saisie manuelle (declaratif)
}

/// Criteres d'evaluation du proprietaire vers le locataire en fin de bail.
/// Chaque critere est objectif, factuel, et non-discriminatoire.
enum LandlordReviewCriterion {
  PAYMENT_REGULARITY    // Regularite des paiements
  PROPERTY_CONDITION    // Etat du logement
  COMMUNICATION         // Communication et reactivite
  WOULD_RECOMMEND       // Recommandation globale
}

/// Niveaux de reponse pour chaque critere d'evaluation.
/// 3 niveaux seulement : positif / neutre / negatif.
/// Pas de granularite excessive pour eviter les biais.
enum ReviewRating {
  POSITIVE    // Bon / Oui / Excellent
  NEUTRAL     // Correct / Parfois / Avec reserves
  NEGATIVE    // Problematique / Non / Degradations
}

// ---- ÉTAT DES LIEUX (EDL) ----

enum InspectionType {
  ENTRY
  EXIT
}

enum InspectionStatus {
  DRAFT
  PENDING_SIGNATURE
  SIGNED
  LOCKED
  AMENDED
  CANCELLED
}

enum MeterType {
  ELECTRICITY
  WATER
  GAS
}

enum InspectionRoomType {
  ENTRY
  HALLWAY
  LIVING
  BEDROOM
  KITCHEN
  BATHROOM
  BATHROOM_WC
  WC
  LAUNDRY
  OFFICE
  DRESSING
  BALCONY
  TERRACE
  CELLAR
  PARKING
  GARAGE
  OTHER
}

enum ElementCategory {
  FLOOR
  WALL
  CEILING
  EQUIPMENT
}

enum ElementCondition {
  NEW
  GOOD
  NORMAL_WEAR
  DEGRADED
  OUT_OF_SERVICE
}

enum ElementEvolution {
  UNCHANGED
  NORMAL_WEAR
  DETERIORATION
  IMPROVEMENT
}

enum PhotoType {
  OVERVIEW
  SURFACE
  DETAIL
  METER
  KEY
}

enum AmendmentStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model RentPaymentTracking {
  id                  String   @id @default(uuid())
  rentalApplicationId String

  periodMonth         Int      // 1-12
  periodYear          Int      // 2026

  expectedAmountCents Int      // Montant attendu
  expectedDate        DateTime @db.Date

  detectedAmountCents Int?
  detectedDate        DateTime?
  transactionId       String?
  isPartialPayment    Boolean  @default(false)

  status              RentPaymentStatus @default(PENDING)

  reminderSentAt      DateTime?
  overdueNotifiedAt   DateTime?
  manuallyConfirmedAt DateTime?
  ignoreReason        String?

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  rentalApplication   RentalApplication @relation(fields: [rentalApplicationId], references: [id], onDelete: Cascade)

  @@unique([rentalApplicationId, periodMonth, periodYear])
  @@index([rentalApplicationId])
  @@index([status])
  @@index([expectedDate])
}

// ── Passeport Locatif ──────────────────────────────────────────────────

/// Historique locatif du locataire.
/// Combine les baux Coridor (remplis automatiquement) et les locations
/// exterieures (saisies manuellement par le locataire).
///
/// Pour les baux Coridor, les champs sont pre-remplis depuis
/// RentalApplication -> Listing -> RentalUnit -> Property.
/// Le locataire ne peut PAS modifier les donnees d'un bail Coridor.
model RentalHistory {
  id                  String               @id @default(uuid())
  tenantProfileId     String
  source              RentalHistorySource  // CORIDOR ou MANUAL

  // ---- Lien Coridor (optionnel, null si MANUAL) ----
  rentalApplicationId String?  @unique   // Bail Coridor associe (1:1)

  // ---- Donnees du bail ----
  city                String               // Ville de la location
  zipCode             String?              // Code postal
  propertyType        RentalPropertyType   // Type de bien
  rentAmountCents     Int?                 // Loyer mensuel approximatif (en centimes)
  startDate           DateTime  @db.Date   // Date d'entree dans le logement
  endDate             DateTime? @db.Date   // Date de sortie (null = en cours)
  landlordName        String?              // Nom du proprietaire/agence (optionnel)

  // ---- Verification ----
  /// true si la source est CORIDOR et le bail est verifie.
  /// false pour les saisies manuelles (non verifiable par Coridor).
  isVerified          Boolean  @default(false)

  // ---- Visibilite ----
  /// Le locataire peut masquer une entree specifique de son Passeport.
  /// Masquee = non visible lors des candidatures, mais toujours stockee.
  isHidden            Boolean  @default(false)

  // ---- Metadata ----
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // ---- Relations ----
  tenantProfile       TenantProfile      @relation(fields: [tenantProfileId], references: [id], onDelete: Cascade)
  rentalApplication   RentalApplication? @relation(fields: [rentalApplicationId], references: [id], onDelete: SetNull)
  landlordReview      LandlordReview?    // Evaluation du proprietaire (0 ou 1 par bail)

  @@index([tenantProfileId])
  @@index([source])
  @@index([startDate])
  @@index([isVerified])
}

/// Evaluation structuree d'un locataire par son ancien proprietaire
/// en fin de bail.
///
/// REGLES :
/// - Liee a un RentalHistory (lui-meme lie a un bail Coridor).
/// - Seul le proprietaire du bail peut remplir l'evaluation.
/// - Le locataire doit avoir donne son consentement.
/// - AUCUN champ texte libre (anti-discrimination by design).
/// - Le locataire peut masquer l'evaluation via isHidden sur RentalHistory.
///
/// Le proprietaire ne peut creer une evaluation QUE si :
/// 1. Le bail est termine (endDate non null) OU en cours de cloture
/// 2. Le bail a dure au minimum 3 mois
/// 3. L'evaluation n'a pas deja ete soumise
model LandlordReview {
  id                String   @id @default(uuid())
  rentalHistoryId   String   @unique  // 1 evaluation par bail
  reviewerId        String             // userId du proprietaire

  // ---- Score composite ----
  /// Calcule cote serveur a partir des scores individuels.
  /// Moyenne simple des ReviewRating converties en numerique :
  /// POSITIVE=3, NEUTRAL=2, NEGATIVE=1 -> Score /3.
  compositeScore    Float

  // ---- Metadata ----
  /// Le locataire a-t-il consenti au partage de cette evaluation ?
  /// L'evaluation est stockee mais non affichee tant que consent = false.
  tenantConsented   Boolean  @default(false)
  consentedAt       DateTime?

  submittedAt       DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // ---- Relations ----
  rentalHistory     RentalHistory       @relation(fields: [rentalHistoryId], references: [id], onDelete: Cascade)
  reviewer          User                @relation("LandlordReviews", fields: [reviewerId], references: [id], onDelete: Cascade)
  scores            LandlordReviewScore[]

  @@index([reviewerId])
  @@index([compositeScore])
}

/// Score individuel pour un critere d'evaluation proprietaire.
/// Chaque evaluation contient exactement 6 scores (un par critere).
model LandlordReviewScore {
  id                String                  @id @default(uuid())
  landlordReviewId  String
  criterion         LandlordReviewCriterion
  rating            ReviewRating

  landlordReview    LandlordReview @relation(fields: [landlordReviewId], references: [id], onDelete: Cascade)

  @@unique([landlordReviewId, criterion])
  @@index([landlordReviewId])
}

/// Preferences de partage du Passeport Locatif.
/// Le locataire controle ce qu'il partage lors de ses candidatures.
///
/// Principe : opt-in. Par defaut, rien n'est partage.
/// Le locataire active les sections qu'il souhaite rendre visibles.
model PassportSettings {
  id                String   @id @default(uuid())
  tenantProfileId   String   @unique

  // ---- Activation globale ----
  /// Le Passeport est-il active ? Si false, rien n'est visible.
  isEnabled         Boolean  @default(false)

  // ---- Sections partageables ----
  /// Chaque toggle controle la visibilite d'une section.
  showPaymentBadge      Boolean @default(true)   // Badge Payeur (Bronze/Silver/Gold)
  showRentalHistory     Boolean @default(true)   // Historique des baux
  showLandlordReviews   Boolean @default(false)  // Evaluations proprietaires
  showFinancialSummary  Boolean @default(false)  // Synthese financiere (revenus, garants)
  showVerifiedMonths    Boolean @default(true)   // Nombre de mois verifies

  // ---- Consentement RGPD ----
  /// Date d'activation initiale du Passeport.
  activatedAt       DateTime?
  /// Date de derniere modification des preferences.
  lastModifiedAt    DateTime?

  // ---- Relations ----
  tenantProfile     TenantProfile @relation(fields: [tenantProfileId], references: [id], onDelete: Cascade)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// ---- Guide d'emménagement post-signature ----
model MoveInGuide {
  id                    String    @id @default(uuid())
  rentalApplicationId   String    @unique
  storiesShownAt        DateTime?
  steps                 Json      // Array de { id: string, completed: boolean, completedAt?: string }
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  rentalApplication     RentalApplication @relation(fields: [rentalApplicationId], references: [id], onDelete: Cascade)
}

// ---- ÉTAT DES LIEUX (EDL) — Modèles ----

model Inspection {
  id                    String           @id @default(uuid())
  type                  InspectionType
  status                InspectionStatus @default(DRAFT)
  applicationId         String
  propertyId            String

  // Parties
  landlordId            String
  tenantId              String?
  tenantPresent         Boolean          @default(true)
  representativeName    String?          // Mandataire si locataire absent
  representativeMandate String?          // URL du mandat (Cloudinary)

  // Dates
  scheduledAt           DateTime?
  startedAt             DateTime?
  completedAt           DateTime?

  // Signatures — stockées en JSON { svg, timestamp, ip, userAgent, geoloc }
  landlordSignature     Json?
  tenantSignature       Json?
  landlordSignedAt      DateTime?
  tenantSignedAt        DateTime?

  // Confirmation du locataire (créneau planifié)
  tenantConfirmedAt     DateTime?

  // Annulation
  cancelledAt           DateTime?

  // Réserves du locataire (texte libre)
  tenantReserves        String?

  // [Sortie] Diff avec l'EDL d'entrée
  entryInspectionId     String?  @unique

  // PDF final
  pdfUrl                String?

  // Observations générales
  generalObservations   String?

  // Relations
  application           RentalApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  property              Property          @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  landlord              User              @relation("InspectionLandlord", fields: [landlordId], references: [id])
  tenant                User?             @relation("InspectionTenant", fields: [tenantId], references: [id])
  entryInspection       Inspection?       @relation("InspectionDiff", fields: [entryInspectionId], references: [id])
  exitInspection        Inspection?       @relation("InspectionDiff")

  meters                InspectionMeter[]
  keys                  InspectionKey[]
  rooms                 InspectionRoom[]
  photos                InspectionPhoto[]
  furniture             InspectionFurniture[]
  amendments            InspectionAmendment[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([applicationId, type])
  @@index([applicationId])
  @@index([landlordId])
  @@index([propertyId])
}

model InspectionMeter {
  id                    String    @id @default(uuid())
  inspectionId          String
  type                  MeterType
  meterNumber           String?   // Numéro du compteur (PDL, PCE, etc.)
  indexValue            String?   // Valeur de l'index (texte pour gérer les virgules)
  photoUrl              String?   // Photo du compteur (Cloudinary)
  photoThumbnailUrl     String?
  noGas                 Boolean   @default(false) // "Pas de gaz" coché

  inspection            Inspection @relation(fields: [inspectionId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([inspectionId, type])
}

model InspectionKey {
  id                    String  @id @default(uuid())
  inspectionId          String
  type                  String  // "Porte", "BAL", "Cave", "Badge", "Télécommande", custom...
  quantity              Int     @default(0)

  inspection            Inspection @relation(fields: [inspectionId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([inspectionId])
}

model InspectionRoom {
  id                    String             @id @default(uuid())
  inspectionId          String
  roomType              InspectionRoomType
  name                  String             // Nom affiché ("Chambre 1", "Salon", etc.)
  order                 Int                @default(0) // Ordre d'affichage
  isCompleted           Boolean            @default(false)
  observations          String?            // Observation générale de la pièce (audio/texte)

  // Lien optionnel vers la Room physique du bien
  physicalRoomId        String?

  inspection            Inspection @relation(fields: [inspectionId], references: [id], onDelete: Cascade)
  physicalRoom          Room?      @relation(fields: [physicalRoomId], references: [id])

  elements              InspectionElement[]
  photos                InspectionPhoto[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([inspectionId])
}

model InspectionElement {
  id                    String           @id @default(uuid())
  inspectionRoomId      String
  category              ElementCategory  // FLOOR, WALL, CEILING, EQUIPMENT
  name                  String           // "Sols", "Murs", "Plafond", "Fenêtre(s)", "Évier", etc.
  nature                String[]         @default([]) // Nature(s) du revêtement : ["Parquet", "Carrelage"]...
  condition             ElementCondition? // Neuf, Bon, Usure norm., Dégradé, H.S.
  isAbsent              Boolean          @default(false) // Équipement inexistant (chip "Absent")
  observations          String?          // Observation texte (dictée ou clavier)
  degradationTypes      String[]         // ["Tache", "Rayure", "Fissure", ...] multi-sélection

  // [Sortie] Comparaison avec l'entrée
  evolution             ElementEvolution?

  inspectionRoom        InspectionRoom @relation(fields: [inspectionRoomId], references: [id], onDelete: Cascade)
  photos                InspectionPhoto[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([inspectionRoomId])
}

model InspectionPhoto {
  id                    String    @id @default(uuid())
  inspectionId          String
  inspectionRoomId      String?
  inspectionElementId   String?
  type                  PhotoType // OVERVIEW, SURFACE, DETAIL, METER, KEY
  url                   String    // URL Cloudinary
  thumbnailUrl          String?   // Thumbnail Cloudinary
  sha256                String?   // Hash SHA-256 de l'original (preuve d'intégrité)

  // Metadata probante
  capturedAt            DateTime  @default(now()) // Timestamp serveur
  latitude              Float?
  longitude             Float?
  deviceInfo            String?   // User-Agent

  inspection            Inspection        @relation(fields: [inspectionId], references: [id], onDelete: Cascade)
  room                  InspectionRoom?   @relation(fields: [inspectionRoomId], references: [id], onDelete: Cascade)
  element               InspectionElement? @relation(fields: [inspectionElementId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([inspectionId])
  @@index([inspectionRoomId])
  @@index([inspectionElementId])
}

model InspectionFurniture {
  id                    String  @id @default(uuid())
  inspectionId          String
  name                  String  // "Lit", "Table", "Canapé", etc.
  quantity              Int     @default(1)
  condition             ElementCondition?
  observations          String?

  inspection            Inspection @relation(fields: [inspectionId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([inspectionId])
}

model InspectionAmendment {
  id                    String          @id @default(uuid())
  inspectionId          String
  requestedBy           String          // userId du demandeur
  status                AmendmentStatus @default(PENDING)
  description           String          // Description de la rectification
  elementId             String?         // Élément concerné (optionnel)
  previousValue         Json?           // Valeur avant rectification
  newValue              Json?           // Valeur après rectification
  respondedAt           DateTime?
  responseNote          String?

  inspection            Inspection @relation(fields: [inspectionId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([inspectionId])
}
